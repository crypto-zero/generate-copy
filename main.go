package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/token"
	"go/types"
	"log"
	"sort"
	"strconv"
	"strings"

	. "github.com/dave/jennifer/jen"

	"golang.org/x/tools/go/packages"
)

type GenerateConfig struct {
	From, To     *types.TypeName
	FunctionName string
	ListFunction bool
}

func LoadGenerateConfigFromPackage(varName string, pkg *packages.Package) (out []*GenerateConfig) {
	for _, f := range pkg.Syntax {
		ast.Inspect(f, func(node ast.Node) bool {
			vSpec, ok := node.(*ast.ValueSpec)
			if !ok || len(vSpec.Names) == 0 || vSpec.Names[0].Name != varName {
				return true
			}
			eLit, ok := vSpec.Values[0].(*ast.CompositeLit)
			if !ok {
				return true
			}
			for _, e := range eLit.Elts {
				eLit, ok := e.(*ast.CompositeLit)
				if !ok {
					continue
				}
				n := len(eLit.Elts)
				if !ok || n < 2 {
					continue
				}
				fromLit, ok1 := eLit.Elts[0].(*ast.CompositeLit)
				toLit, ok2 := eLit.Elts[1].(*ast.CompositeLit)
				if !ok1 || !ok2 {
					continue
				}
				fromSel, ok1 := fromLit.Type.(*ast.SelectorExpr)
				toSel, ok2 := toLit.Type.(*ast.SelectorExpr)
				if !ok1 || !ok2 {
					continue
				}
				fromObj, toObj := pkg.TypesInfo.Uses[fromSel.Sel], pkg.TypesInfo.Uses[toSel.Sel]
				if fromObj == nil || toObj == nil {
					continue
				}
				fromTN, ok1 := fromObj.(*types.TypeName)
				toTN, ok2 := toObj.(*types.TypeName)
				if !ok1 || !ok2 {
					continue
				}
				if !fromTN.Exported() || !toObj.Exported() {
					continue
				}
				cfg := &GenerateConfig{From: fromTN, To: toTN}
				if n > 2 {
					if bl, ok := eLit.Elts[2].(*ast.BasicLit); ok && bl.Kind == token.STRING && bl.Value != "" {
						if v, err := strconv.Unquote(bl.Value); err == nil && v != "" {
							cfg.FunctionName = v
						}
					}
				}
				if n > 3 {
					if id, ok := eLit.Elts[3].(*ast.Ident); ok && id.Name == "true" {
						cfg.ListFunction = true
					}
				}
				out = append(out, cfg)
			}
			return false
		})
	}

	return
}

func main() {
	fOutputFilePath := flag.String("output-path", "copy_message.go", "Generate output file path")
	fOutputPkgPath := flag.String("output-pkg-path", "", "Generate output package path")
	flag.Parse()

	pLoadCfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo |
			packages.NeedModule | packages.NeedDeps | packages.NeedImports |
			packages.NeedSyntax,
	}
	currentPkgs, err := packages.Load(pLoadCfg, ".")
	if err != nil {
		log.Fatal("load current path package failed: ", err)
	}
	currentPkg := currentPkgs[0]
	outputPkgPath := currentPkg.PkgPath
	if *fOutputPkgPath != "" {
		outputPkgPath = *fOutputPkgPath
	}
	cfgs := LoadGenerateConfigFromPackage("GenerateCopyStructs", currentPkg)
	if len(cfgs) == 0 {
		log.Fatal("nothing to do.")
	}

	f := NewFilePath(outputPkgPath)
	f.HeaderComment("Code generated by generate-copy, DO NOT EDIT.")

	for _, c := range cfgs {
		TypePair{
			From:         NewTTypeNamed(c.From),
			To:           NewTTypeNamed(c.To),
			FunctionName: c.FunctionName,
			TargetPath:   outputPkgPath,
			ListFunction: c.ListFunction,
		}.Generate(f)
	}

	if err = f.Save(*fOutputFilePath); err != nil {
		log.Fatal("error when saving generate file: ", err)
	}
}

func DecodeType(pointer bool, t types.Type) (isPointer bool, basic *types.Basic,
	named *types.Named, s *types.Struct,
) {
	isPointer = pointer
	switch t := t.(type) {
	case *types.Named:
		switch nt := t.Underlying().(type) {
		case *types.Struct:
			return isPointer, nil, t, nt
		case *types.Basic:
			return isPointer, nt, t, nil
		}
	case *types.Basic:
		return isPointer, t, nil, nil
	case *types.Pointer:
		if isPointer {
			panic("no support for nested pointers")
		}
		return DecodeType(true, t.Elem())
	}
	return
}

func WalkStruct(s *types.Struct, parentVarList TVarList) (out []TVarList) {
	for i := 0; i < s.NumFields(); i++ {
		f := s.Field(i)
		tv := NewTVar(f)
		if !tv.IsPublic() {
			continue
		}
		_, b, _, s := tv.DecodeType()
		if b != nil || tv.IsTime() {
			out = append(out, append(append(TVarList{}, parentVarList...), tv))
			continue
		}
		out = append(out, WalkStruct(s, append(append(TVarList{}, parentVarList...), tv))...)
	}
	return out
}

type TVar struct {
	*types.Var
}

func NewTVar(Var *types.Var) TVar {
	return TVar{Var: Var}
}

func (v TVar) DecodeType() (isPointer bool, basic *types.Basic, named *types.Named,
	s *types.Struct,
) {
	return DecodeType(false, v.Var.Type())
}

func (v TVar) TypeExported() bool {
	_, _, n, _ := v.DecodeType()
	return n == nil || n.Obj().Exported()
}

func (v TVar) IsPublic() bool {
	return v.Exported() && v.TypeExported()
}

func (v TVar) IsTime() bool {
	_, _, n, _ := v.DecodeType()
	return n != nil && n.Obj().Pkg().Path() == "time" && n.Obj().Name() == "Time"
}

func (v TVar) IsInt64() bool {
	_, b, _, _ := v.DecodeType()
	return b != nil && b.Kind() == types.Int64
}

type TVarList []TVar

func (vl TVarList) DecodeType() (isPointer bool, basic *types.Basic, named *types.Named,
	s *types.Struct,
) {
	if n := len(vl); n > 0 {
		return vl[n-1].DecodeType()
	}
	return
}

func (vl TVarList) IsTime() bool {
	if n := len(vl); n > 0 {
		return vl[n-1].IsTime()
	}
	return false
}

func (vl TVarList) IsInt64() bool {
	if n := len(vl); n > 0 {
		return vl[n-1].IsInt64()
	}
	return false
}

func (vl TVarList) Path(guess bool) (out string) {
	var names []string
	for _, v := range vl {
		if guess && v.Embedded() {
			continue
		}
		names = append(names, v.Name())
	}
	return strings.Join(names, ".")
}

func (vl TVarList) Parents() (out []TVarList) {
	for n, j := len(vl), 1; j < n; j++ {
		out = append(out, append(TVarList{}, vl[:n-j]...))
	}
	return
}

func (vl TVarList) PointerParents() (out []TVarList) {
	for j := 0; j < len(vl); j++ {
		if _, ok := vl[j].Type().(*types.Pointer); ok {
			out = append(out, append(TVarList{}, vl[:j+1]...))
		}
	}
	return
}

type TFieldMapping struct {
	From, To         TVarList
	FromPath, ToPath string
	Generator
}

func BuildFieldMappings(fromFields, toFields []TVarList) (out []*TFieldMapping) {
	fromPathMap := make(map[string]struct{})
	for _, f := range fromFields {
		fromPathMap[f.Path(false)] = struct{}{}
	}
Fields:
	for _, fromField := range fromFields {
		fromPath, fromGPath := fromField.Path(false), fromField.Path(true)
		_, gPathConflict := fromPathMap[fromGPath]
		for _, toField := range toFields {
			if tp := toField.Path(false); tp == fromPath {
				out = append(out, &TFieldMapping{
					From: fromField, To: toField,
					FromPath: fromPath, ToPath: tp,
				})
				continue Fields
			}
		}
		for _, toField := range toFields {
			if tp, tgp := toField.Path(false), toField.Path(true); tp == fromGPath && !gPathConflict {
				out = append(out, &TFieldMapping{
					From: fromField, To: toField,
					FromPath: fromGPath, ToPath: tp,
				})
				continue Fields
			} else if tgp == fromPath {
				out = append(out, &TFieldMapping{
					From: fromField, To: toField,
					FromPath: fromPath, ToPath: tgp,
				})
				continue Fields
			}
		}
	}
	return
}

type Generator func(group *Group)

type TFieldMappingResolver func(mapping TFieldMapping) (resolver Generator)

var FieldMappingResolvers = []TFieldMappingResolver{
	BasicFieldMappingResolver(true),
	TimeToUnixMappingResolver,
	Int64ToTimeMappingResolver,
}

func statementAppendBasicCast(basic *types.Basic, s *Statement) *Statement {
	switch basic.Kind() {
	case types.Bool:
		return s.Bool()
	case types.Int:
		return s.Int()
	case types.Int8:
		return s.Int8()
	case types.Int16:
		return s.Int16()
	case types.Int32:
		return s.Int32()
	case types.Int64:
		return s.Int64()
	case types.Uint:
		return s.Uint()
	case types.Uint8:
		return s.Uint8()
	case types.Uint16:
		return s.Uint16()
	case types.Uint32:
		return s.Uint32()
	case types.Uint64:
		return s.Uint64()
	case types.Float32:
		return s.Float32()
	case types.Float64:
		return s.Float64()
	case types.String:
		return s.String()
	}
	return s
}

func allowedMixedCastBasicInfo(bi types.BasicInfo) bool {
	return bi&types.IsInteger > 0 || bi&types.IsFloat > 0
}

func BasicFieldMappingResolver(supportNumberCast bool) TFieldMappingResolver {
	return func(m TFieldMapping) Generator {
		_, ft, fn, _ := m.From.DecodeType()
		_, tt, tn, _ := m.To.DecodeType()
		if ft == nil || tt == nil {
			return nil
		}
		castBasic := false
		if ft.Kind() != tt.Kind() {
			if !supportNumberCast {
				return nil
			}
			ok1, ok2 := allowedMixedCastBasicInfo(ft.Info()), allowedMixedCastBasicInfo(tt.Info())
			if !ok1 || !ok2 {
				return nil
			}
			castBasic = true
		}
		return func(g *Group) {
			if fn == nil && tn == nil { // basic type cast
				s := g.Id("out").Dot(m.ToPath).Op("=")
				if castBasic {
					s = statementAppendBasicCast(tt, s).Call(Id("f").Dot(m.FromPath))
				} else {
					s.Id("f").Dot(m.FromPath)
				}
			} else if fn != nil && tn == nil { // from type is alias basic but to is basic
				s := g.Id("out").Dot(m.ToPath).Op("=")
				s = statementAppendBasicCast(tt, s).Call(Id("f").Dot(m.FromPath))
			} else if fn == nil && tn != nil { // from is basic but to is alias basic
				s := g.Id("out").Dot(m.ToPath).Op("=")
				s = s.Qual(tn.Obj().Pkg().Path(), tn.Obj().Name()).Call(Id("f").Dot(m.FromPath))
			}
		}
	}
}

func TimeToUnixMappingResolver(m TFieldMapping) Generator {
	if !m.From.IsTime() || !m.To.IsInt64() {
		return nil
	}
	return func(g *Group) {
		g.Id("out").Dot(m.ToPath).Op("=").Id("f").Dot(m.FromPath).Dot("Unix").Call()
	}
}

func Int64ToTimeMappingResolver(m TFieldMapping) Generator {
	if !m.To.IsTime() || !m.From.IsInt64() {
		return nil
	}
	return func(g *Group) {
		g.Id("out").Dot(m.ToPath).Op("=").Qual("time", "Unix").Call(Id("f").Dot(m.FromPath), Lit(0))
	}
}

type TTypeNamed struct {
	*types.TypeName
}

func NewTTypeNamed(typeName *types.TypeName) TTypeNamed {
	return TTypeNamed{TypeName: typeName}
}

func (tn TTypeNamed) WalkPublicVars() (out []TVarList) {
	n := tn.Type().(*types.Named)
	s := n.Underlying().(*types.Struct)
	return WalkStruct(s, nil)
}

func MatchWithResolvers(fm []*TFieldMapping, resolvers []TFieldMappingResolver) (out []*TFieldMapping) {
	for _, f := range fm {
		for _, r := range resolvers {
			if resolver := r(*f); resolver != nil {
				f.Generator = resolver
				out = append(out, f)
				break
			}
		}
	}
	return out
}

func GenerateInitialTargetSubStructs(list []*TFieldMapping, g *Group) {
	initializeStructs := make(map[string]TVarList)
	for _, fr := range list {
		for _, fp := range fr.To.Parents() {
			initializeStructs[fp.Path(false)] = fp
		}
	}
	var initializeStructList []TVarList
	for _, vars := range initializeStructs {
		initializeStructList = append(initializeStructList, vars)
	}
	sort.Slice(initializeStructList, func(i, j int) bool {
		return len(initializeStructList[i]) < len(initializeStructList[j])
	})
	for _, s := range initializeStructList {
		structVar := s[len(s)-1]
		var ptrOps []Code
		isPointer, _, named, _ := structVar.DecodeType()
		if isPointer {
			ptrOps = []Code{Op("&")}
		}
		g.Id("out").Dot(s.Path(false)).Op("=").Add(ptrOps...).Qual(named.Obj().Pkg().Path(),
			named.Obj().Name()).Values()
	}
}

func GenerateFieldMappings(list []*TFieldMapping, g *Group) {
	for _, fr := range list {
		g.Do(func(s *Statement) {
			pointerParents := fr.From.PointerParents()
			if len(pointerParents) == 0 {
				fr.Generator(g)
				return
			}
			s.IfFunc(func(g *Group) {
				n := len(pointerParents) - 1
				g.Do(func(s *Statement) {
					for idx, v := range pointerParents {
						s.Id("f").Dot(v.Path(false)).Op("!=").Nil()
						if idx != n {
							s.Op("&&")
						}
					}
				})
			}).BlockFunc(func(g *Group) {
				fr.Generator(g)
			})
		})
	}
}

type TypePair struct {
	From, To                 TTypeNamed
	FunctionName, TargetPath string
	ListFunction             bool
}

func (tp TypePair) GetFunctionName() string {
	if tp.FunctionName == "" {
		return fmt.Sprintf("From%sTo%s", tp.From.Name(), tp.To.Name())
	}
	return tp.FunctionName
}

func (tp TypePair) GetListFunctionName() string {
	return tp.GetFunctionName() + "List"
}

func (tp TypePair) Generate(f *File) {
	fromFields := tp.From.WalkPublicVars()
	toFields := tp.To.WalkPublicVars()
	mappings := BuildFieldMappings(fromFields, toFields)
	mappings = MatchWithResolvers(mappings, FieldMappingResolvers)

	ftn, ttn := tp.From.Name(), tp.To.Name()

	f.Func().Id(tp.GetFunctionName()).
		Params(
			Id("f").Op("*").Qual(tp.From.Pkg().Path(), ftn),
		).
		Params(
			Id("out").Op("*").Qual(tp.To.Pkg().Path(), ttn),
		).
		BlockFunc(func(g *Group) {
			g.Id("out").Op("=").Op("&").Qual(tp.To.Pkg().Path(), ttn).Values()
			GenerateInitialTargetSubStructs(mappings, g)
			GenerateFieldMappings(mappings, g)
			g.Return()
		})

	if !tp.ListFunction {
		return
	}

	f.Func().Id(tp.GetListFunctionName()).
		Params(
			Id("fs").Index().Op("*").Qual(tp.From.Pkg().Path(), ftn),
		).
		Params(
			Id("out").Index().Op("*").Qual(tp.To.Pkg().Path(), ttn),
		).
		BlockFunc(func(g *Group) {
			g.Id("out").Op("=").Make(Index().Op("*").Qual(tp.To.Pkg().Path(), ttn), Lit(0), Len(Id("fs")))
			g.For(Id("_").Op(",").Id("f").Op(":=").Range().Id("fs")).Block(
				If(Id("f").Op("!=").Nil()).Block(
					Id("out").Op("=").Append(Id("out"), Id(tp.GetFunctionName()).Call(Id("f"))),
				),
			)
			g.Return()
		})
}
